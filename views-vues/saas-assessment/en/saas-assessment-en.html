---
layout: default
title: SaaS Assessment Tool (Draft)
lang: en
altLang: fr
altLangPage: saas-assessment-fr
collectionDirectory: views-vues/saas-assessment
welcome:
  heading: SaaS Assessment Triage Tool
  intro1: This tool will help determine SaaS requirements.
  intro2: More explanation
questionnaire:
  heading: Questionnaire
  questions:
    "1":
      question: Website of SaaS web address
    "2":
      question: Data Classification
      prompt: Select a classification
      options: [
        Unclassified,
        Protected A,
        Protected B
      ]
---
<script type="text/javascript" src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
<script>
  async function getSpreadsheet(worksheetName, cellName, suggestedState) {
    let response
    let spreadsheetArrayBuffer

    try {
      response = await fetch('/gcdigital-tools_outils-numeriquesgc/CCCS MEDIUM - Assessors Workbook - Local Assessment.xlsx')
    } catch (e) {
      console.log("Error when fetching assessment spreadsheet: ", e)
    }

    try {
      spreadsheetArrayBuffer = await response.arrayBuffer()
    } catch (e) {
      console.log("Error when creating arrayBuffer from spreadsheet: ", e)
    }

    const spreadsheetData = new Uint8Array(spreadsheetArrayBuffer)
    const workbook = XLSX.read(spreadsheetData, { type: "array" })
    const worksheet = workbook.Sheets[worksheetName]

    const selectedCellNameObj = workbook.Workbook.Names.find((nameObject) => {
      return nameObject.Name === cellName
    })
    console.log(`Retrieved cell ${cellName}`, selectedCellNameObj)

    let cell = workbook[selectedCellNameObj.Ref];
    const cellNumber = selectedCellNameObj.Ref.split('!')[1].replaceAll('$', '')

    if (typeof cell === 'undefined' || typeof cell?.v === 'undefined') {
      XLSX.utils.sheet_add_aoa(worksheet, [[suggestedState]], {origin: cellNumber});
    } else {
      cell.v = suggestedState;
    }

    // write to new file
    // formatting from OLD file will be lost!
    XLSX.writeFile(workbook, 'CSSS Assessor Workbook.xlsx');
  }

  function getFormData() {
    let elements = document.getElementById("saas-assessment-form").elements;
    let obj = {};
    for (let i = 0; i < elements.length - 1; i++) {
      let item = elements.item(i);
      obj[item.id] = item.value;
    }
    return obj;
  }

  function getTier() {
    const data = getFormData();
    const dataClassification = data["question-2"];
    if (dataClassification === 'Unclassified') return 0;
    else if (dataClassification === 'Protected A') return 1;
    else if (dataClassification === 'Protected B') return 2;
    else return -1;
  }

  async function getTLSGuidance() {
    const address = "https://raw.githubusercontent.com/CybercentreCanada/ITSP.40.062/main/transport-layer-security/tls-guidance.json";
    try {
      const res = await fetch(address);
      const data = await res.json();
      return data;
    } catch (e) {
      console.log("Error when fetching guidance: ", e);
    }
  }

  async function requestScan() {
    const data = getFormData();
    const SaaSAddress = data["question-1"];
    const address = `http://localhost:8000/scan/${SaaSAddress}`

    if (SaaSAddress === "") {
      console.log("Please enter web address")
      return -1;
    }

    try {
      const res = await fetch(address);
      return await res.json();
    } catch (e) {
      console.log("Error when fetching guidance: ", e);
    }
  }

  async function GCHTTPSRules() {
    let guidance;
    let analysis;
    let results = [];

    // get data
    try {
      guidance = await getTLSGuidance();
      analysis = await requestScan();
    } catch(err) {
      console.error("Error retrieving data:", err);
      return -1;
    }

    analysis.results.forEach(({ ipAddress, 'connectivity_status': statusMessage, scan_result }) => {
      // handle error status messages
      if (
        statusMessage === "ERROR"
      ) {
        results = [{
          returnValue: -10000,
          decisionTypeAid: "C2",
          message: "Error or no secure protocols found.",
        }];
      }

      Object.keys(scan_result).forEach((v) => {
        if (scan_result[v].result) {
          const { tls_version_used, accepted_cipher_suites, rejected_cipher_suites } = scan_result[v]?.result;
          if (tls_version_used === "TLS_1_3") {
            const { recommended, sufficient } = guidance.ciphers["1.3"];
            accepted_cipher_suites.forEach(({ cipher_suite }) => {
              const { name } = cipher_suite;
              if (recommended.indexOf(name) > -1) {
                results.push({
                  returnValue: 100,
                  decisionAidType: "C2",
                  message: `TLS 1.3 recommended cipher found: ${name}`
                });
              } else if (sufficient.indexOf(name) > -1) {
                results.push({
                  returnValue: 99,
                  decisionAidType: "C2",
                  message: `TLS 1.3 sufficient cipher found: ${name}`
                });
              } else {
                results.push({
                  returnValue: -1111,
                  decisionAidType: "C2",
                  message: `TLS 1.3 cipher not approved for use: ${name}`
                });
              }
            });

          }
          else if (tls_version_used === "TLS_1_2") {
            const { recommended, sufficient, phase_out } = guidance.ciphers["1.2"];
            accepted_cipher_suites.forEach(({ cipher_suite }) => {
              const { name } = cipher_suite;
              if (recommended.indexOf(name) > -1) {
                results.push({
                  returnValue: 100,
                  decisionAidType: "C2",
                  message: `TLS 1.2 recommended cipher found: ${name}`
                });
              } else if (sufficient.indexOf(name) > -1) {
                results.push({
                  returnValue: 99,
                  decisionAidType: "C2",
                  message: `TLS 1.2 sufficient cipher found: ${name}`
                });
              } else if (phase_out.indexOf(name) > -1) {
                results.push({
                  returnValue: 98,
                  decisionAidType: "C2",
                  message: `The use of the following cipher is allowed, however it is being phased out: ${name}`
                });
              } else {
                results.push({
                  returnValue: -1111,
                  decisionAidType: "C2",
                  message: `TLS 1.2 cipher not approved for use: ${name}`
                });
              }
            });
          }
          else {
            if (accepted_cipher_suites.length > 0) {
              results.push({
                returnValue: -1000,
                decisionAidType: "C2",
                message: `The use of ${tls_version_used} is discouraged.`
              }); 
            }
          }
        }
      })
    });
    return results;
  }

  async function updateRowSaaS_SC8() {
    console.log("start update row SC8");
    let results;
    let suggestedState
    try {
      results = await GCHTTPSRules();
    } catch (err) {
      console.error("Error when gathering results:", err);
      return -1;
    }
    console.log(results);
    suggestedState = suggestAssessmentState(results, "SC8", "S_DB_S", false, true);
    await getSpreadsheet("SC", "SC8_DECISION", suggestedState);
  }

  function suggestAssessmentState(results, row, worksheet, canInherit = true, canBeFullyMet = false) {
    let decisionAidFinal = "";
    let decisionAidPositive = [];
    let decisionAidNegative = [];
    let decisionAidNeutral = [];
    let suggestedState = "TBD";
    let inherited = "";
    let outOfScope = false;
    let isInherited = false;

    // TODO
    if (canInherit) {
      console.log("can inherit");
    }

    if (results.length > 0) {
      results.forEach(({ returnValue, message }) => {
        if (returnValue >= 1) {
          console.log("decisionAidPositive");
          decisionAidPositive.push(message);
        } else if (returnValue <= -1) {
          console.log("decisionAidNegative");
          decisionAidNegative.push(message);
        } else { // returnValue === 0
          console.log("decisionAidNeutral");
          decisionAidNeutral.push(message);
        }
      })

      if (canBeFullyMet) {
        if (decisionAidPositive.length > 0 && decisionAidNegative.length > 0){
          suggestedState = "Partial";
        } else if (decisionAidPositive.length > 0 && decisionAidNegative.length === 0) {
          suggestedState = "Met";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length === 0 && decisionAidNeutral.length > 0) {
          suggestedState = "None";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length > 0) {
          suggestedState = "Not Met";
        } else {
          suggestedState = "None";
        }
      } else {
        if (
          (decisionAidPositive.length > 0 && decisionAidNegative.length > 0) ||
          (decisionAidPositive.length > 0 && decisionAidNegative.length === 0)
        ) {
          suggestedState = "Partial";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length === 0 && decisionAidNeutral.length > 0) {
          suggestedState = "None";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length > 0) {
          suggestedState = "Not Met";
        } else {
          suggestedState = "None";
        }
      }
      if (outOfScope || isInherited) {
        suggestedState = inherited;
      }
    } else {
      if (outOfScope || isInherited) {
        suggestedState = inherited;
      } else {
        suggestedState = "None";
      }
    }

    console.log("Suggested State: ", suggestedState)
    return suggestedState;
  }

  function isInherited(cellName, controlName) {
    const intTier = getTier();
    console.log("getTier() == ", intTier);
    console.log("cellname: ", cellName);
    console.log("controlName: ", controlName);
  }

</script>

{% include views-vues/saas-assessment/saas-assessment-intro.html %}

{% include views-vues/saas-assessment/saas-assessment-questionnaire.html %}

<br />
<button onclick="updateRowSaaS_SC8()">Print</button>

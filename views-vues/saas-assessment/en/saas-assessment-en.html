---
layout: default
title: SaaS Assessment Tool (Draft)
lang: en
altLang: fr
altLangPage: saas-assessment-fr
collectionDirectory: views-vues/saas-assessment
welcome:
  heading: SaaS Assessment Triage Tool
  intro1: This tool will help determine SaaS requirements.
  intro2: More explanation
questionnaire:
  heading: Questionnaire
  questions:
    "1":
      question: Website of SaaS web address
    "2":
      question: Data Classification
      prompt: Select a classification
      options: [
        Unclassified,
        Protected A,
        Protected B
      ]
---
<!--
  TODO:
    turn HTML into MD,
    fix CORS error on SSLLabs fetch,
    implement inherit logic in suggestAssessmentState()
-->
<script type="text/javascript" src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
<script>
  async function getSpreadsheet() {
    let response
    let spreadsheetArrayBuffer
    let suggestedState

    try {
      response = await fetch('/gcdigital-tools_outils-numeriquesgc/CCCS MEDIUM - Assessors Workbook - Local Assessment.xlsx')
    } catch (e) {
      console.log("Error when fetching assessment spreadsheet: ", e)
    }

    try {
      spreadsheetArrayBuffer = await response.arrayBuffer()
    } catch (e) {
      console.log("Error when creating arrayBuffer from spreadsheet: ", e)
    }

    try {
      suggestedState = await updateRowSaaS_SC8();
    } catch (e) {
      console.log("Error when assessing suggested state: ", e)
    }
    console.log(suggestedState)

    const spreadsheetData = new Uint8Array(spreadsheetArrayBuffer)
    const workbook = XLSX.read(spreadsheetData, { type: "array" })

    const firstWorksheet = workbook.SheetNames[0]
    const worksheet = workbook.Sheets["SC"]
    // console.log(workbook)
    // console.log(worksheet)

    const selectedCellNameObj = workbook.Workbook.Names.find((nameObject) => {
      return nameObject.Name === 'SC8_DECISION'
    })
    console.log(`Retrieved cell "SC8_DECISION"`, selectedCellNameObj)

    let cell = worksheet['M20'];
    console.log(cell)

    if (typeof cell === 'undefined' || typeof cell?.v === 'undefined') {
      XLSX.utils.sheet_add_aoa(worksheet, [[suggestedState]], {origin: 'M20'});
    } else {
      cell.v = suggestedState;
    }

    // write to new file
    // formatting from OLD file will be lost!
    XLSX.writeFile(workbook, 'CSSS Assessor Workbook.xlsx');
  }

  function getFormData() {
    let elements = document.getElementById("saas-assessment-form").elements;
    let obj = {};
    for (let i = 0; i < elements.length - 1; i++) {
      let item = elements.item(i);
      obj[item.id] = item.value;
    }
    return obj;
  }

  function getTier() {
    const data = getFormData();
    const dataClassification = data["question-2"];
    if (dataClassification === 'Unclassified') return 0;
    else if (dataClassification === 'Protected A') return 1;
    else if (dataClassification === 'Protected B') return 2;
    else return -1;
  }

  async function getTLSGuidance() {
    const address = "https://raw.githubusercontent.com/CybercentreCanada/ITSP.40.062/main/transport-layer-security/tls-guidance.json";
    try {
      const res = await fetch(address);
      const data = await res.json();
      return data;
    } catch (e) {
      console.log("Error when fetching guidance: ", e);
    }
  }

  async function requestScan() {
    const data = getFormData();
    const SaaSAddress = data["question-1"];
    /* TODO: handle CORS error */
    // const address = `https://api.ssllabs.com/api/v3/analyze?all=done&fromCache=on&maxAge=168&host=${SaaSAddress}`
    // const address = "/gcdigital-tools_outils-numeriquesgc/views-vues/saas-assessment/en/canada-ca_data.json"
    const address = `http://localhost:8000/scan/canada.ca`

    // if (SaaSAddress === "") {
    //   console.log("Please enter web address")
    //   return -1;
    // }

    try {
      const res = await fetch(address);
      return await res.json();
    } catch (e) {
      console.log("Error when fetching guidance: ", e);
    }
  }

  async function GCHTTPSRules() {
    let guidance;
    let analysis;
    let results = [];

    // get data
    try {
      guidance = await getTLSGuidance();
      analysis = await requestScan();
    } catch(err) {
      console.error("Error retrieving data:", err);
      return -1;
    }

    analysis.results.forEach(({ ipAddress, 'connectivity_status': statusMessage, details }) => {
      // handle error status messages
      if (
        statusMessage === "ERROR"
      ) {
        // console.log("No secure protocols found on endpoint")
        results = [{
          returnValue: -10000,
          decisionTypeAid: "C2",
          message: "Error or no secure protocols found.",
        }];
      }

      // investigate protocol ciphers
      for (let i = 0; i < details.protocols.length; i++) {
        const { version } = details.protocols[i];
        // if TLS v1.3
        if (version === "1.3") {
          const { recommended, sufficient } = guidance.ciphers["1.3"];
          details.suites[i].list.forEach(({ name }) => {
            if (recommended.indexOf(name) > -1) {
              results.push({
                returnValue: 100,
                decisionAidType: "C2",
                message: `TLS 1.3 recommended cipher found: ${name}`
              });
            } else if (sufficient.indexOf(name) > -1) {
              results.push({
                returnValue: 99,
                decisionAidType: "C2",
                message: `TLS 1.3 sufficient cipher found: ${name}`
              });
            } else {
              results.push({
                returnValue: -1111,
                decisionAidType: "C2",
                message: `TLS 1.3 cipher not approved for use: ${name}`
              });
            }
          })
        }
        // if TLS v1.2
        else if (version === "1.2") {
          const { recommended, sufficient, phase_out } = guidance.ciphers["1.2"];
          details.suites[i].list.forEach(({ name }) => {
            if (recommended.indexOf(name) > -1) {
              results.push({
                returnValue: 100,
                decisionAidType: "C2",
                message: `TLS 1.2 recommended cipher found: ${name}`
              });
            } else if (sufficient.indexOf(name) > -1) {
              results.push({
                returnValue: 99,
                decisionAidType: "C2",
                message: `TLS 1.2 sufficient cipher found: ${name}`
              });
            } else if (phase_out.indexOf(name) > -1) {
              results.push({
                returnValue: 98,
                decisionAidType: "C2",
                message: `The use of the following cipher is allowed, however it is being phased out: ${name}`
              });
            } else {
              results.push({
                returnValue: -1111,
                decisionAidType: "C2",
                message: `TLS 1.2 cipher not approved for use: ${name}`
              });
            }
          })
        }
        // else bad TLS
        else {
          results.push({
            returnValue: -1000,
            decisionAidType: "C2",
            message: `The use of TLS/SSL version ${version} is discouraged.`
          });
        }
      }
    });
    return results;
  }

  async function updateRowSaaS_SC8() {
    console.log("start update row SC8");
    let results;
    try {
      results = await GCHTTPSRules();
    } catch (err) {
      console.error("Error when gathering results:", err);
      return -1;
    }
    console.log(results);
    return suggestAssessmentState(results, "SC8", "S_DB_S", false, true);
  }

  function suggestAssessmentState(results, row, worksheet, canInherit = true, canBeFullyMet = false) {
    let decisionAidFinal = "";
    let decisionAidPositive = [];
    let decisionAidNegative = [];
    let decisionAidNeutral = [];
    let suggestedState = "TBD";
    let inherited = "";
    let outOfScope = false;
    let isInherited = false;

    intTier = getTier();
    console.log("getTier() == ", intTier) ;

    // TODO
    if (canInherit) {
      console.log("can inherit");
    }

    if (results.length > 0) {
      results.forEach(({ returnValue, message }) => {
        if (returnValue >= 1) {
          console.log("decisionAidPositive");
          decisionAidPositive.push(message);
        } else if (returnValue <= -1) {
          console.log("decisionAidNegative");
          decisionAidNegative.push(message);
        } else { // returnValue === 0
          console.log("decisionAidNeutral");
          decisionAidNeutral.push(message);
        }
      })

      // print all messages
      // if (decisionAidPositive.length > 0) {
      //   console.log("Positives:", decisionAidPositive.length)
      //   // decisionAidPositive.forEach((message) => {
      //   //   console.log(message);
      //   // })
      // }
      // if (decisionAidNegative.length > 0) {
      //   console.log("Negatives:", decisionAidNegative.length);
      //   // decisionAidPositive.forEach((message) => {
      //   //   console.log(message);
      //   // })
      // }
      // if (decisionAidNeutral.length > 0) {
      //   console.log("Neutral:", decisionAidNeutral.length);
      //   // decisionAidPositive.forEach((message) => {
      //   //   console.log(message);
      //   // })
      // }

      if (canBeFullyMet) {
        if (decisionAidPositive.length > 0 && decisionAidNegative.length > 0){
          suggestedState = "Partial";
        } else if (decisionAidPositive.length > 0 && decisionAidNegative.length === 0) {
          suggestedState = "Met";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length === 0 && decisionAidNeutral.length > 0) {
          suggestedState = "None";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length > 0) {
          suggestedState = "Not Met";
        } else {
          suggestedState = "None";
        }
      } else {
        if (
          (decisionAidPositive.length > 0 && decisionAidNegative.length > 0) ||
          (decisionAidPositive.length > 0 && decisionAidNegative.length === 0)
        ) {
          suggestedState = "Partial";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length === 0 && decisionAidNeutral.length > 0) {
          suggestedState = "None";
        } else if (decisionAidPositive.length === 0 && decisionAidNegative.length > 0) {
          suggestedState = "Not Met";
        } else {
          suggestedState = "None";
        }
      }
      if (outOfScope || isInherited) {
        suggestedState = inherited;
      }
    } else {
      if (outOfScope || isInherited) {
        suggestedState = inherited;
      } else {
        suggestedState = "None";
      }
    }

    console.log("Suggested State: ", suggestedState)
    return suggestedState;
  }

</script>

{% include views-vues/saas-assessment/saas-assessment-intro.html %}

<button onclick="getSpreadsheet()">Print</button>

{% include views-vues/saas-assessment/saas-assessment-questionnaire.html %}

